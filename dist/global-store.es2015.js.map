{"version":3,"file":"global-store.es2015.js","sources":["../../../../../../global-store/getStore.ts"],"sourcesContent":["\n/**\n * Store interface.\n */\nexport interface Store<T> {\n  /**\n   * ID of the store.\n   */\n  id: string\n\n  /**\n   * The store value.\n   */\n  value: T\n}\n\n/**\n * Store implementation.\n * The Store interface and StoreImpl is separated so that\n * consumer cannot get access to the StoreImpl class to instantiate it directly.\n */\nclass StoreImpl<T> implements Store<T> {\n  value: T\n\n  /**\n   * `defaultValue` is default to `{}` to support simple hash.\n   * If consumer use this is simple type store (`string`, `number` etc),\n   * this `{}` is wasted but it is a trade off to be made.\n   */\n  constructor(public id: string, defaultValue: T = {} as T) {\n    this.value = defaultValue\n   }\n}\n\nconst globalState: { [i: string]: Store<any> } = {}\n\n/**\n * Gets or creates a store.\n * @param id A unique identifier to the store.\n * This id MUST be unique across all modules in an application.\n * You should make it descriptive.\n * You should use your module's name or unique key as part of the id.\n * @param defaultValue Optional, but most of the time you will specify it.\n * You can skip the defaultValue for very basic use cases: basic types and hash.\n */\nexport function getStore<T>(id: string, defaultValue?: T): Store<T> {\n  return globalState[id] = globalState[id] || new StoreImpl<T>(id, defaultValue)\n}\n\n/**\n * Remove a store from the global state.\n * Internal for testing only\n */\nexport function removeStore(store: Store<any>): void {\n  if (store) {\n    delete globalState[store.id]\n  }\n}\n"],"names":["id","defaultValue","globalState","StoreImpl","[object Object]","this","value"],"mappings":"yBA6CA,YAA4BA,EAAYC,GACtC,MAAOC,GAAYF,GAAME,EAAYF,IAAO,GAAIG,GAAaH,EAAIC,WAjBjEG,YAAmBJ,EAAYC,MAAZI,QAAAL,EACjBK,KAAKC,MAAQL,GAIjB,KAAMC"}